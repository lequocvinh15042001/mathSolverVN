{"ast":null,"code":"// Inline parser state\n'use strict';\n\nvar Token = require('../token');\n\nvar isWhiteSpace = require('../common/utils').isWhiteSpace;\n\nvar isPunctChar = require('../common/utils').isPunctChar;\n\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\nfunction StateInline(src, md, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.md = md;\n  this.tokens = outTokens;\n  this.tokens_meta = Array(outTokens.length);\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0; // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n\n  this.cache = {}; // List of emphasis-like delimiters for current tag\n\n  this.delimiters = []; // Stack of delimiter lists for upper level tags\n\n  this._prev_delimiters = []; // backtick length => last seen position\n\n  this.backticks = {};\n  this.backticksScanned = false;\n} // Flush pending text\n//\n\n\nStateInline.prototype.pushPending = function () {\n  var token = new Token('text', '', 0);\n  token.content = this.pending;\n  token.level = this.pendingLevel;\n  this.tokens.push(token);\n  this.pending = '';\n  return token;\n}; // Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\n\n\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  var token = new Token(type, tag, nesting);\n  var token_meta = null;\n\n  if (nesting < 0) {\n    // closing tag\n    this.level--;\n    this.delimiters = this._prev_delimiters.pop();\n  }\n\n  token.level = this.level;\n\n  if (nesting > 0) {\n    // opening tag\n    this.level++;\n\n    this._prev_delimiters.push(this.delimiters);\n\n    this.delimiters = [];\n    token_meta = {\n      delimiters: this.delimiters\n    };\n  }\n\n  this.pendingLevel = this.level;\n  this.tokens.push(token);\n  this.tokens_meta.push(token_meta);\n  return token;\n}; // Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\n\n\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  var pos = start,\n      lastChar,\n      nextChar,\n      count,\n      can_open,\n      can_close,\n      isLastWhiteSpace,\n      isLastPunctChar,\n      isNextWhiteSpace,\n      isNextPunctChar,\n      left_flanking = true,\n      right_flanking = true,\n      max = this.posMax,\n      marker = this.src.charCodeAt(start); // treat beginning of the line as a whitespace\n\n  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;\n\n  while (pos < max && this.src.charCodeAt(pos) === marker) {\n    pos++;\n  }\n\n  count = pos - start; // treat end of the line as a whitespace\n\n  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n\n  if (isNextWhiteSpace) {\n    left_flanking = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false;\n    }\n  }\n\n  if (isLastWhiteSpace) {\n    right_flanking = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false;\n    }\n  }\n\n  if (!canSplitWord) {\n    can_open = left_flanking && (!right_flanking || isLastPunctChar);\n    can_close = right_flanking && (!left_flanking || isNextPunctChar);\n  } else {\n    can_open = left_flanking;\n    can_close = right_flanking;\n  }\n\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    length: count\n  };\n}; // re-export Token class to use in block rules\n\n\nStateInline.prototype.Token = Token;\nmodule.exports = StateInline;","map":{"version":3,"names":["Token","require","isWhiteSpace","isPunctChar","isMdAsciiPunct","StateInline","src","md","env","outTokens","tokens","tokens_meta","Array","length","pos","posMax","level","pending","pendingLevel","cache","delimiters","_prev_delimiters","backticks","backticksScanned","prototype","pushPending","token","content","push","type","tag","nesting","token_meta","pop","scanDelims","start","canSplitWord","lastChar","nextChar","count","can_open","can_close","isLastWhiteSpace","isLastPunctChar","isNextWhiteSpace","isNextPunctChar","left_flanking","right_flanking","max","marker","charCodeAt","String","fromCharCode","module","exports"],"sources":["/Users/lequocvinh/MathSolver/mathSolverVN/node_modules/markdown-it/lib/rules_inline/state_inline.js"],"sourcesContent":["// Inline parser state\n\n'use strict';\n\n\nvar Token          = require('../token');\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\nvar isPunctChar    = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\n\nfunction StateInline(src, md, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.md = md;\n  this.tokens = outTokens;\n  this.tokens_meta = Array(outTokens.length);\n\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n\n  // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  this.cache = {};\n\n  // List of emphasis-like delimiters for current tag\n  this.delimiters = [];\n\n  // Stack of delimiter lists for upper level tags\n  this._prev_delimiters = [];\n\n  // backtick length => last seen position\n  this.backticks = {};\n  this.backticksScanned = false;\n}\n\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  var token = new Token('text', '', 0);\n  token.content = this.pending;\n  token.level = this.pendingLevel;\n  this.tokens.push(token);\n  this.pending = '';\n  return token;\n};\n\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  var token = new Token(type, tag, nesting);\n  var token_meta = null;\n\n  if (nesting < 0) {\n    // closing tag\n    this.level--;\n    this.delimiters = this._prev_delimiters.pop();\n  }\n\n  token.level = this.level;\n\n  if (nesting > 0) {\n    // opening tag\n    this.level++;\n    this._prev_delimiters.push(this.delimiters);\n    this.delimiters = [];\n    token_meta = { delimiters: this.delimiters };\n  }\n\n  this.pendingLevel = this.level;\n  this.tokens.push(token);\n  this.tokens_meta.push(token_meta);\n  return token;\n};\n\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  var pos = start, lastChar, nextChar, count, can_open, can_close,\n      isLastWhiteSpace, isLastPunctChar,\n      isNextWhiteSpace, isNextPunctChar,\n      left_flanking = true,\n      right_flanking = true,\n      max = this.posMax,\n      marker = this.src.charCodeAt(start);\n\n  // treat beginning of the line as a whitespace\n  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;\n\n  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++; }\n\n  count = pos - start;\n\n  // treat end of the line as a whitespace\n  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;\n\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n\n  if (isNextWhiteSpace) {\n    left_flanking = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false;\n    }\n  }\n\n  if (isLastWhiteSpace) {\n    right_flanking = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false;\n    }\n  }\n\n  if (!canSplitWord) {\n    can_open  = left_flanking  && (!right_flanking || isLastPunctChar);\n    can_close = right_flanking && (!left_flanking  || isNextPunctChar);\n  } else {\n    can_open  = left_flanking;\n    can_close = right_flanking;\n  }\n\n  return {\n    can_open:  can_open,\n    can_close: can_close,\n    length:    count\n  };\n};\n\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token;\n\n\nmodule.exports = StateInline;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}