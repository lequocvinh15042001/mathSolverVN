{"ast":null,"code":"import { isPromise } from './util.js';\nimport { chooseMethod } from './method-chooser.js';\nimport { fillOptionsWithDefaults } from './options.js';\nexport var BroadcastChannel = function BroadcastChannel(name, options) {\n  this.name = name;\n\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n\n  this.options = fillOptionsWithDefaults(options);\n  this.method = chooseMethod(this.options); // isListening\n\n  this._iL = false;\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n\n  this._onML = null;\n  /**\n   * _addEventListeners\n   */\n\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n  /**\n   * Unsend message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */\n\n  this._uMP = new Set();\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n\n  this._befC = [];\n  /**\n   * _preparePromise\n   */\n\n  this._prepP = null;\n\n  _prepareChannel(this);\n}; // STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\n\nBroadcastChannel._pubkey = true;\n/**\n * clears the tmp-folder if is node\n * @return {Promise<boolean>} true if has run, false if not node\n */\n\nexport function clearNodeFolder(options) {\n  options = fillOptionsWithDefaults(options);\n  var method = chooseMethod(options);\n\n  if (method.type === 'node') {\n    return method.clearNodeFolder().then(function () {\n      return true;\n    });\n  } else {\n    return Promise.resolve(false);\n  }\n}\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\n\nvar ENFORCED_OPTIONS;\nexport function enforceOptions(options) {\n  ENFORCED_OPTIONS = options;\n} // PROTOTYPE\n\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed');\n    }\n\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _removeListenerObject(this, 'message', this._onML);\n\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : Promise.resolve();\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare // wait until all current sending are processed\n    .then(function () {\n      return Promise.all(Array.from(_this._uMP));\n    }) // run before-close hooks\n    .then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    }) // close the channel\n    .then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n\n  get type() {\n    return this.method.type;\n  },\n\n  get isClosed() {\n    return this.closed;\n  }\n\n};\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */\n\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : Promise.resolve();\n  return awaitPrepare.then(function () {\n    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj); // add/remove to unsend messages list\n\n    broadcastChannel._uMP.add(sendPromise);\n\n    sendPromise[\"catch\"]().then(function () {\n      return broadcastChannel._uMP[\"delete\"](sendPromise);\n    });\n    return sendPromise;\n  });\n}\n\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n\n  if (isPromise(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\n\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\n\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n\n  _startListening(channel);\n}\n\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n\n  _stopListening(channel);\n}\n\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (obj) {\n        if (msgObj.time >= obj.time) {\n          obj.fn(msgObj.data);\n        }\n      });\n    };\n\n    var time = channel.method.microSeconds();\n\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\n\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}","map":{"version":3,"names":["isPromise","chooseMethod","fillOptionsWithDefaults","BroadcastChannel","name","options","ENFORCED_OPTIONS","method","_iL","_onML","_addEL","message","internal","_uMP","Set","_befC","_prepP","_prepareChannel","_pubkey","clearNodeFolder","type","then","Promise","resolve","enforceOptions","prototype","postMessage","msg","closed","Error","_post","postInternal","onmessage","fn","time","microSeconds","listenObj","_removeListenerObject","_addListenerObject","addEventListener","removeEventListener","obj","find","close","_this","awaitPrepare","all","Array","from","map","_state","isClosed","broadcastChannel","msgObj","data","sendPromise","add","channel","maybePromise","create","s","_hasMessageListeners","length","push","_startListening","filter","o","_stopListening","listenerFn","forEach","onMessage"],"sources":["/Users/lequocvinh/MathSolver/mathSolverVN/node_modules/broadcast-channel/dist/es/broadcast-channel.js"],"sourcesContent":["import { isPromise } from './util.js';\nimport { chooseMethod } from './method-chooser.js';\nimport { fillOptionsWithDefaults } from './options.js';\nexport var BroadcastChannel = function BroadcastChannel(name, options) {\n  this.name = name;\n\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n\n  this.options = fillOptionsWithDefaults(options);\n  this.method = chooseMethod(this.options); // isListening\n\n  this._iL = false;\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n\n  this._onML = null;\n  /**\n   * _addEventListeners\n   */\n\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n  /**\n   * Unsend message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */\n\n  this._uMP = new Set();\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n\n  this._befC = [];\n  /**\n   * _preparePromise\n   */\n\n  this._prepP = null;\n\n  _prepareChannel(this);\n}; // STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\n\nBroadcastChannel._pubkey = true;\n/**\n * clears the tmp-folder if is node\n * @return {Promise<boolean>} true if has run, false if not node\n */\n\nexport function clearNodeFolder(options) {\n  options = fillOptionsWithDefaults(options);\n  var method = chooseMethod(options);\n\n  if (method.type === 'node') {\n    return method.clearNodeFolder().then(function () {\n      return true;\n    });\n  } else {\n    return Promise.resolve(false);\n  }\n}\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\n\nvar ENFORCED_OPTIONS;\nexport function enforceOptions(options) {\n  ENFORCED_OPTIONS = options;\n} // PROTOTYPE\n\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed');\n    }\n\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _removeListenerObject(this, 'message', this._onML);\n\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : Promise.resolve();\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare // wait until all current sending are processed\n    .then(function () {\n      return Promise.all(Array.from(_this._uMP));\n    }) // run before-close hooks\n    .then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    }) // close the channel\n    .then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n\n  get type() {\n    return this.method.type;\n  },\n\n  get isClosed() {\n    return this.closed;\n  }\n\n};\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */\n\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : Promise.resolve();\n  return awaitPrepare.then(function () {\n    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj); // add/remove to unsend messages list\n\n    broadcastChannel._uMP.add(sendPromise);\n\n    sendPromise[\"catch\"]().then(function () {\n      return broadcastChannel._uMP[\"delete\"](sendPromise);\n    });\n    return sendPromise;\n  });\n}\n\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n\n  if (isPromise(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\n\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\n\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n\n  _startListening(channel);\n}\n\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n\n  _stopListening(channel);\n}\n\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (obj) {\n        if (msgObj.time >= obj.time) {\n          obj.fn(msgObj.data);\n        }\n      });\n    };\n\n    var time = channel.method.microSeconds();\n\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\n\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}"],"mappings":"AAAA,SAASA,SAAT,QAA0B,WAA1B;AACA,SAASC,YAAT,QAA6B,qBAA7B;AACA,SAASC,uBAAT,QAAwC,cAAxC;AACA,OAAO,IAAIC,gBAAgB,GAAG,SAASA,gBAAT,CAA0BC,IAA1B,EAAgCC,OAAhC,EAAyC;EACrE,KAAKD,IAAL,GAAYA,IAAZ;;EAEA,IAAIE,gBAAJ,EAAsB;IACpBD,OAAO,GAAGC,gBAAV;EACD;;EAED,KAAKD,OAAL,GAAeH,uBAAuB,CAACG,OAAD,CAAtC;EACA,KAAKE,MAAL,GAAcN,YAAY,CAAC,KAAKI,OAAN,CAA1B,CARqE,CAQ3B;;EAE1C,KAAKG,GAAL,GAAW,KAAX;EACA;AACF;AACA;AACA;AACA;;EAEE,KAAKC,KAAL,GAAa,IAAb;EACA;AACF;AACA;;EAEE,KAAKC,MAAL,GAAc;IACZC,OAAO,EAAE,EADG;IAEZC,QAAQ,EAAE;EAFE,CAAd;EAIA;AACF;AACA;AACA;AACA;;EAEE,KAAKC,IAAL,GAAY,IAAIC,GAAJ,EAAZ;EACA;AACF;AACA;AACA;AACA;;EAEE,KAAKC,KAAL,GAAa,EAAb;EACA;AACF;AACA;;EAEE,KAAKC,MAAL,GAAc,IAAd;;EAEAC,eAAe,CAAC,IAAD,CAAf;AACD,CA/CM,C,CA+CJ;;AAEH;AACA;AACA;AACA;AACA;;AAEAd,gBAAgB,CAACe,OAAjB,GAA2B,IAA3B;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,eAAT,CAAyBd,OAAzB,EAAkC;EACvCA,OAAO,GAAGH,uBAAuB,CAACG,OAAD,CAAjC;EACA,IAAIE,MAAM,GAAGN,YAAY,CAACI,OAAD,CAAzB;;EAEA,IAAIE,MAAM,CAACa,IAAP,KAAgB,MAApB,EAA4B;IAC1B,OAAOb,MAAM,CAACY,eAAP,GAAyBE,IAAzB,CAA8B,YAAY;MAC/C,OAAO,IAAP;IACD,CAFM,CAAP;EAGD,CAJD,MAIO;IACL,OAAOC,OAAO,CAACC,OAAR,CAAgB,KAAhB,CAAP;EACD;AACF;AACD;AACA;AACA;AACA;;AAEA,IAAIjB,gBAAJ;AACA,OAAO,SAASkB,cAAT,CAAwBnB,OAAxB,EAAiC;EACtCC,gBAAgB,GAAGD,OAAnB;AACD,C,CAAC;;AAEFF,gBAAgB,CAACsB,SAAjB,GAA6B;EAC3BC,WAAW,EAAE,SAASA,WAAT,CAAqBC,GAArB,EAA0B;IACrC,IAAI,KAAKC,MAAT,EAAiB;MACf,MAAM,IAAIC,KAAJ,CAAU,qCAAqC,8CAA/C,CAAN;IACD;;IAED,OAAOC,KAAK,CAAC,IAAD,EAAO,SAAP,EAAkBH,GAAlB,CAAZ;EACD,CAP0B;EAQ3BI,YAAY,EAAE,SAASA,YAAT,CAAsBJ,GAAtB,EAA2B;IACvC,OAAOG,KAAK,CAAC,IAAD,EAAO,UAAP,EAAmBH,GAAnB,CAAZ;EACD,CAV0B;;EAY3B,IAAIK,SAAJ,CAAcC,EAAd,EAAkB;IAChB,IAAIC,IAAI,GAAG,KAAK3B,MAAL,CAAY4B,YAAZ,EAAX;IACA,IAAIC,SAAS,GAAG;MACdF,IAAI,EAAEA,IADQ;MAEdD,EAAE,EAAEA;IAFU,CAAhB;;IAKAI,qBAAqB,CAAC,IAAD,EAAO,SAAP,EAAkB,KAAK5B,KAAvB,CAArB;;IAEA,IAAIwB,EAAE,IAAI,OAAOA,EAAP,KAAc,UAAxB,EAAoC;MAClC,KAAKxB,KAAL,GAAa2B,SAAb;;MAEAE,kBAAkB,CAAC,IAAD,EAAO,SAAP,EAAkBF,SAAlB,CAAlB;IACD,CAJD,MAIO;MACL,KAAK3B,KAAL,GAAa,IAAb;IACD;EACF,CA5B0B;;EA8B3B8B,gBAAgB,EAAE,SAASA,gBAAT,CAA0BnB,IAA1B,EAAgCa,EAAhC,EAAoC;IACpD,IAAIC,IAAI,GAAG,KAAK3B,MAAL,CAAY4B,YAAZ,EAAX;IACA,IAAIC,SAAS,GAAG;MACdF,IAAI,EAAEA,IADQ;MAEdD,EAAE,EAAEA;IAFU,CAAhB;;IAKAK,kBAAkB,CAAC,IAAD,EAAOlB,IAAP,EAAagB,SAAb,CAAlB;EACD,CAtC0B;EAuC3BI,mBAAmB,EAAE,SAASA,mBAAT,CAA6BpB,IAA7B,EAAmCa,EAAnC,EAAuC;IAC1D,IAAIQ,GAAG,GAAG,KAAK/B,MAAL,CAAYU,IAAZ,EAAkBsB,IAAlB,CAAuB,UAAUD,GAAV,EAAe;MAC9C,OAAOA,GAAG,CAACR,EAAJ,KAAWA,EAAlB;IACD,CAFS,CAAV;;IAIAI,qBAAqB,CAAC,IAAD,EAAOjB,IAAP,EAAaqB,GAAb,CAArB;EACD,CA7C0B;EA8C3BE,KAAK,EAAE,SAASA,KAAT,GAAiB;IACtB,IAAIC,KAAK,GAAG,IAAZ;;IAEA,IAAI,KAAKhB,MAAT,EAAiB;MACf;IACD;;IAED,KAAKA,MAAL,GAAc,IAAd;IACA,IAAIiB,YAAY,GAAG,KAAK7B,MAAL,GAAc,KAAKA,MAAnB,GAA4BM,OAAO,CAACC,OAAR,EAA/C;IACA,KAAKd,KAAL,GAAa,IAAb;IACA,KAAKC,MAAL,CAAYC,OAAZ,GAAsB,EAAtB;IACA,OAAOkC,YAAY,CAAC;IAAD,CAClBxB,IADM,CACD,YAAY;MAChB,OAAOC,OAAO,CAACwB,GAAR,CAAYC,KAAK,CAACC,IAAN,CAAWJ,KAAK,CAAC/B,IAAjB,CAAZ,CAAP;IACD,CAHM,EAGJ;IAHI,CAINQ,IAJM,CAID,YAAY;MAChB,OAAOC,OAAO,CAACwB,GAAR,CAAYF,KAAK,CAAC7B,KAAN,CAAYkC,GAAZ,CAAgB,UAAUhB,EAAV,EAAc;QAC/C,OAAOA,EAAE,EAAT;MACD,CAFkB,CAAZ,CAAP;IAGD,CARM,EAQJ;IARI,CASNZ,IATM,CASD,YAAY;MAChB,OAAOuB,KAAK,CAACrC,MAAN,CAAaoC,KAAb,CAAmBC,KAAK,CAACM,MAAzB,CAAP;IACD,CAXM,CAAP;EAYD,CArE0B;;EAuE3B,IAAI9B,IAAJ,GAAW;IACT,OAAO,KAAKb,MAAL,CAAYa,IAAnB;EACD,CAzE0B;;EA2E3B,IAAI+B,QAAJ,GAAe;IACb,OAAO,KAAKvB,MAAZ;EACD;;AA7E0B,CAA7B;AAgFA;AACA;AACA;AACA;;AAEA,SAASE,KAAT,CAAesB,gBAAf,EAAiChC,IAAjC,EAAuCO,GAAvC,EAA4C;EAC1C,IAAIO,IAAI,GAAGkB,gBAAgB,CAAC7C,MAAjB,CAAwB4B,YAAxB,EAAX;EACA,IAAIkB,MAAM,GAAG;IACXnB,IAAI,EAAEA,IADK;IAEXd,IAAI,EAAEA,IAFK;IAGXkC,IAAI,EAAE3B;EAHK,CAAb;EAKA,IAAIkB,YAAY,GAAGO,gBAAgB,CAACpC,MAAjB,GAA0BoC,gBAAgB,CAACpC,MAA3C,GAAoDM,OAAO,CAACC,OAAR,EAAvE;EACA,OAAOsB,YAAY,CAACxB,IAAb,CAAkB,YAAY;IACnC,IAAIkC,WAAW,GAAGH,gBAAgB,CAAC7C,MAAjB,CAAwBmB,WAAxB,CAAoC0B,gBAAgB,CAACF,MAArD,EAA6DG,MAA7D,CAAlB,CADmC,CACqD;;IAExFD,gBAAgB,CAACvC,IAAjB,CAAsB2C,GAAtB,CAA0BD,WAA1B;;IAEAA,WAAW,CAAC,OAAD,CAAX,GAAuBlC,IAAvB,CAA4B,YAAY;MACtC,OAAO+B,gBAAgB,CAACvC,IAAjB,CAAsB,QAAtB,EAAgC0C,WAAhC,CAAP;IACD,CAFD;IAGA,OAAOA,WAAP;EACD,CATM,CAAP;AAUD;;AAED,SAAStC,eAAT,CAAyBwC,OAAzB,EAAkC;EAChC,IAAIC,YAAY,GAAGD,OAAO,CAAClD,MAAR,CAAeoD,MAAf,CAAsBF,OAAO,CAACrD,IAA9B,EAAoCqD,OAAO,CAACpD,OAA5C,CAAnB;;EAEA,IAAIL,SAAS,CAAC0D,YAAD,CAAb,EAA6B;IAC3BD,OAAO,CAACzC,MAAR,GAAiB0C,YAAjB;IACAA,YAAY,CAACrC,IAAb,CAAkB,UAAUuC,CAAV,EAAa;MAC7B;;MAEA;AACN;AACA;MACMH,OAAO,CAACP,MAAR,GAAiBU,CAAjB;IACD,CAPD;EAQD,CAVD,MAUO;IACLH,OAAO,CAACP,MAAR,GAAiBQ,YAAjB;EACD;AACF;;AAED,SAASG,oBAAT,CAA8BJ,OAA9B,EAAuC;EACrC,IAAIA,OAAO,CAAC/C,MAAR,CAAeC,OAAf,CAAuBmD,MAAvB,GAAgC,CAApC,EAAuC,OAAO,IAAP;EACvC,IAAIL,OAAO,CAAC/C,MAAR,CAAeE,QAAf,CAAwBkD,MAAxB,GAAiC,CAArC,EAAwC,OAAO,IAAP;EACxC,OAAO,KAAP;AACD;;AAED,SAASxB,kBAAT,CAA4BmB,OAA5B,EAAqCrC,IAArC,EAA2CqB,GAA3C,EAAgD;EAC9CgB,OAAO,CAAC/C,MAAR,CAAeU,IAAf,EAAqB2C,IAArB,CAA0BtB,GAA1B;;EAEAuB,eAAe,CAACP,OAAD,CAAf;AACD;;AAED,SAASpB,qBAAT,CAA+BoB,OAA/B,EAAwCrC,IAAxC,EAA8CqB,GAA9C,EAAmD;EACjDgB,OAAO,CAAC/C,MAAR,CAAeU,IAAf,IAAuBqC,OAAO,CAAC/C,MAAR,CAAeU,IAAf,EAAqB6C,MAArB,CAA4B,UAAUC,CAAV,EAAa;IAC9D,OAAOA,CAAC,KAAKzB,GAAb;EACD,CAFsB,CAAvB;;EAIA0B,cAAc,CAACV,OAAD,CAAd;AACD;;AAED,SAASO,eAAT,CAAyBP,OAAzB,EAAkC;EAChC,IAAI,CAACA,OAAO,CAACjD,GAAT,IAAgBqD,oBAAoB,CAACJ,OAAD,CAAxC,EAAmD;IACjD;IACA,IAAIW,UAAU,GAAG,SAASA,UAAT,CAAoBf,MAApB,EAA4B;MAC3CI,OAAO,CAAC/C,MAAR,CAAe2C,MAAM,CAACjC,IAAtB,EAA4BiD,OAA5B,CAAoC,UAAU5B,GAAV,EAAe;QACjD,IAAIY,MAAM,CAACnB,IAAP,IAAeO,GAAG,CAACP,IAAvB,EAA6B;UAC3BO,GAAG,CAACR,EAAJ,CAAOoB,MAAM,CAACC,IAAd;QACD;MACF,CAJD;IAKD,CAND;;IAQA,IAAIpB,IAAI,GAAGuB,OAAO,CAAClD,MAAR,CAAe4B,YAAf,EAAX;;IAEA,IAAIsB,OAAO,CAACzC,MAAZ,EAAoB;MAClByC,OAAO,CAACzC,MAAR,CAAeK,IAAf,CAAoB,YAAY;QAC9BoC,OAAO,CAACjD,GAAR,GAAc,IAAd;QACAiD,OAAO,CAAClD,MAAR,CAAe+D,SAAf,CAAyBb,OAAO,CAACP,MAAjC,EAAyCkB,UAAzC,EAAqDlC,IAArD;MACD,CAHD;IAID,CALD,MAKO;MACLuB,OAAO,CAACjD,GAAR,GAAc,IAAd;MACAiD,OAAO,CAAClD,MAAR,CAAe+D,SAAf,CAAyBb,OAAO,CAACP,MAAjC,EAAyCkB,UAAzC,EAAqDlC,IAArD;IACD;EACF;AACF;;AAED,SAASiC,cAAT,CAAwBV,OAAxB,EAAiC;EAC/B,IAAIA,OAAO,CAACjD,GAAR,IAAe,CAACqD,oBAAoB,CAACJ,OAAD,CAAxC,EAAmD;IACjD;IACAA,OAAO,CAACjD,GAAR,GAAc,KAAd;IACA,IAAI0B,IAAI,GAAGuB,OAAO,CAAClD,MAAR,CAAe4B,YAAf,EAAX;IACAsB,OAAO,CAAClD,MAAR,CAAe+D,SAAf,CAAyBb,OAAO,CAACP,MAAjC,EAAyC,IAAzC,EAA+ChB,IAA/C;EACD;AACF"},"metadata":{},"sourceType":"module"}