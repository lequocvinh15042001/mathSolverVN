{"ast":null,"code":"/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n */\nimport { sleep, randomInt, randomToken, microSeconds as micro, isNode } from '../util.js';\nexport var microSeconds = micro;\nimport { ObliviousSet } from 'oblivious-set';\nimport { fillOptionsWithDefaults } from '../options';\nvar DB_PREFIX = 'pubkey.broadcast-channel-0-';\nvar OBJECT_STORE_ID = 'messages';\nexport var type = 'idb';\nexport function getIdb() {\n  if (typeof indexedDB !== 'undefined') return indexedDB;\n\n  if (typeof window !== 'undefined') {\n    if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\n    if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\n    if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\n  }\n\n  return false;\n}\nexport function createDatabase(channelName) {\n  var IndexedDB = getIdb(); // create table\n\n  var dbName = DB_PREFIX + channelName;\n  var openRequest = IndexedDB.open(dbName, 1);\n\n  openRequest.onupgradeneeded = function (ev) {\n    var db = ev.target.result;\n    db.createObjectStore(OBJECT_STORE_ID, {\n      keyPath: 'id',\n      autoIncrement: true\n    });\n  };\n\n  var dbPromise = new Promise(function (res, rej) {\n    openRequest.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    openRequest.onsuccess = function () {\n      res(openRequest.result);\n    };\n  });\n  return dbPromise;\n}\n/**\n * writes the new message to the database\n * so other readers can find it\n */\n\nexport function writeMessage(db, readerUuid, messageJson) {\n  var time = new Date().getTime();\n  var writeObject = {\n    uuid: readerUuid,\n    time: time,\n    data: messageJson\n  };\n  var transaction = db.transaction([OBJECT_STORE_ID], 'readwrite');\n  return new Promise(function (res, rej) {\n    transaction.oncomplete = function () {\n      return res();\n    };\n\n    transaction.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    var objectStore = transaction.objectStore(OBJECT_STORE_ID);\n    objectStore.add(writeObject);\n  });\n}\nexport function getAllMessages(db) {\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        ret.push(cursor.value); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n        cursor[\"continue\"]();\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function getMessagesHigherThan(db, lastCursorId) {\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n\n  function openCursor() {\n    // Occasionally Safari will fail on IDBKeyRange.bound, this\n    // catches that error, having it open the cursor to the first\n    // item. When it gets data it will advance to the desired key.\n    try {\n      var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n      return objectStore.openCursor(keyRangeValue);\n    } catch (e) {\n      return objectStore.openCursor();\n    }\n  }\n\n  return new Promise(function (res) {\n    openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        if (cursor.value.id < lastCursorId + 1) {\n          cursor[\"continue\"](lastCursorId + 1);\n        } else {\n          ret.push(cursor.value);\n          cursor[\"continue\"]();\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function removeMessageById(db, id) {\n  var request = db.transaction([OBJECT_STORE_ID], 'readwrite').objectStore(OBJECT_STORE_ID)[\"delete\"](id);\n  return new Promise(function (res) {\n    request.onsuccess = function () {\n      return res();\n    };\n  });\n}\nexport function getOldMessages(db, ttl) {\n  var olderThen = new Date().getTime() - ttl;\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        var msgObk = cursor.value;\n\n        if (msgObk.time < olderThen) {\n          ret.push(msgObk); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n          cursor[\"continue\"]();\n        } else {\n          // no more old messages,\n          res(ret);\n          return;\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function cleanOldMessages(db, ttl) {\n  return getOldMessages(db, ttl).then(function (tooOld) {\n    return Promise.all(tooOld.map(function (msgObj) {\n      return removeMessageById(db, msgObj.id);\n    }));\n  });\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  return createDatabase(channelName).then(function (db) {\n    var state = {\n      closed: false,\n      lastCursorId: 0,\n      channelName: channelName,\n      options: options,\n      uuid: randomToken(),\n\n      /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */\n      eMIs: new ObliviousSet(options.idb.ttl * 2),\n      // ensures we do not read messages in parrallel\n      writeBlockPromise: Promise.resolve(),\n      messagesCallback: null,\n      readQueuePromises: [],\n      db: db\n    };\n    /**\n     * Handle abrupt closes that do not originate from db.close().\n     * This could happen, for example, if the underlying storage is\n     * removed or if the user clears the database in the browser's\n     * history preferences.\n     */\n\n    db.onclose = function () {\n      state.closed = true;\n      if (options.idb.onclose) options.idb.onclose();\n    };\n    /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */\n\n\n    _readLoop(state);\n\n    return state;\n  });\n}\n\nfunction _readLoop(state) {\n  if (state.closed) return;\n  readNewMessages(state).then(function () {\n    return sleep(state.options.idb.fallbackInterval);\n  }).then(function () {\n    return _readLoop(state);\n  });\n}\n\nfunction _filterMessage(msgObj, state) {\n  if (msgObj.uuid === state.uuid) return false; // send by own\n\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\n\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n\n  return true;\n}\n/**\n * reads all new messages from the database and emits them\n */\n\n\nfunction readNewMessages(state) {\n  // channel already closed\n  if (state.closed) return Promise.resolve(); // if no one is listening, we do not need to scan for new messages\n\n  if (!state.messagesCallback) return Promise.resolve();\n  return getMessagesHigherThan(state.db, state.lastCursorId).then(function (newerMessages) {\n    var useMessages = newerMessages\n    /**\n     * there is a bug in iOS where the msgObj can be undefined some times\n     * so we filter them out\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\n     */\n    .filter(function (msgObj) {\n      return !!msgObj;\n    }).map(function (msgObj) {\n      if (msgObj.id > state.lastCursorId) {\n        state.lastCursorId = msgObj.id;\n      }\n\n      return msgObj;\n    }).filter(function (msgObj) {\n      return _filterMessage(msgObj, state);\n    }).sort(function (msgObjA, msgObjB) {\n      return msgObjA.time - msgObjB.time;\n    }); // sort by time\n\n    useMessages.forEach(function (msgObj) {\n      if (state.messagesCallback) {\n        state.eMIs.add(msgObj.id);\n        state.messagesCallback(msgObj.data);\n      }\n    });\n    return Promise.resolve();\n  });\n}\n\nexport function close(channelState) {\n  channelState.closed = true;\n  channelState.db.close();\n}\nexport function postMessage(channelState, messageJson) {\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {\n    return writeMessage(channelState.db, channelState.uuid, messageJson);\n  }).then(function () {\n    if (randomInt(0, 10) === 0) {\n      /* await (do not await) */\n      cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n    }\n  });\n  return channelState.writeBlockPromise;\n}\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n  readNewMessages(channelState);\n}\nexport function canBeUsed() {\n  if (isNode) return false;\n  var idb = getIdb();\n  if (!idb) return false;\n  return true;\n}\nexport function averageResponseTime(options) {\n  return options.idb.fallbackInterval * 2;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","map":{"version":3,"names":["sleep","randomInt","randomToken","microSeconds","micro","isNode","ObliviousSet","fillOptionsWithDefaults","DB_PREFIX","OBJECT_STORE_ID","type","getIdb","indexedDB","window","mozIndexedDB","webkitIndexedDB","msIndexedDB","createDatabase","channelName","IndexedDB","dbName","openRequest","open","onupgradeneeded","ev","db","target","result","createObjectStore","keyPath","autoIncrement","dbPromise","Promise","res","rej","onerror","onsuccess","writeMessage","readerUuid","messageJson","time","Date","getTime","writeObject","uuid","data","transaction","oncomplete","objectStore","add","getAllMessages","ret","openCursor","cursor","push","value","getMessagesHigherThan","lastCursorId","keyRangeValue","IDBKeyRange","bound","Infinity","e","id","removeMessageById","request","getOldMessages","ttl","olderThen","msgObk","cleanOldMessages","then","tooOld","all","map","msgObj","create","options","state","closed","eMIs","idb","writeBlockPromise","resolve","messagesCallback","readQueuePromises","onclose","_readLoop","readNewMessages","fallbackInterval","_filterMessage","has","messagesCallbackTime","newerMessages","useMessages","filter","sort","msgObjA","msgObjB","forEach","close","channelState","postMessage","onMessage","fn","canBeUsed","averageResponseTime"],"sources":["/Users/lequocvinh/MathSolver/mathSolverVN/node_modules/broadcast-channel/dist/es/methods/indexed-db.js"],"sourcesContent":["/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n */\nimport { sleep, randomInt, randomToken, microSeconds as micro, isNode } from '../util.js';\nexport var microSeconds = micro;\nimport { ObliviousSet } from 'oblivious-set';\nimport { fillOptionsWithDefaults } from '../options';\nvar DB_PREFIX = 'pubkey.broadcast-channel-0-';\nvar OBJECT_STORE_ID = 'messages';\nexport var type = 'idb';\nexport function getIdb() {\n  if (typeof indexedDB !== 'undefined') return indexedDB;\n\n  if (typeof window !== 'undefined') {\n    if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\n    if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\n    if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\n  }\n\n  return false;\n}\nexport function createDatabase(channelName) {\n  var IndexedDB = getIdb(); // create table\n\n  var dbName = DB_PREFIX + channelName;\n  var openRequest = IndexedDB.open(dbName, 1);\n\n  openRequest.onupgradeneeded = function (ev) {\n    var db = ev.target.result;\n    db.createObjectStore(OBJECT_STORE_ID, {\n      keyPath: 'id',\n      autoIncrement: true\n    });\n  };\n\n  var dbPromise = new Promise(function (res, rej) {\n    openRequest.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    openRequest.onsuccess = function () {\n      res(openRequest.result);\n    };\n  });\n  return dbPromise;\n}\n/**\n * writes the new message to the database\n * so other readers can find it\n */\n\nexport function writeMessage(db, readerUuid, messageJson) {\n  var time = new Date().getTime();\n  var writeObject = {\n    uuid: readerUuid,\n    time: time,\n    data: messageJson\n  };\n  var transaction = db.transaction([OBJECT_STORE_ID], 'readwrite');\n  return new Promise(function (res, rej) {\n    transaction.oncomplete = function () {\n      return res();\n    };\n\n    transaction.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    var objectStore = transaction.objectStore(OBJECT_STORE_ID);\n    objectStore.add(writeObject);\n  });\n}\nexport function getAllMessages(db) {\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        ret.push(cursor.value); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n        cursor[\"continue\"]();\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function getMessagesHigherThan(db, lastCursorId) {\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n\n  function openCursor() {\n    // Occasionally Safari will fail on IDBKeyRange.bound, this\n    // catches that error, having it open the cursor to the first\n    // item. When it gets data it will advance to the desired key.\n    try {\n      var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n      return objectStore.openCursor(keyRangeValue);\n    } catch (e) {\n      return objectStore.openCursor();\n    }\n  }\n\n  return new Promise(function (res) {\n    openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        if (cursor.value.id < lastCursorId + 1) {\n          cursor[\"continue\"](lastCursorId + 1);\n        } else {\n          ret.push(cursor.value);\n          cursor[\"continue\"]();\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function removeMessageById(db, id) {\n  var request = db.transaction([OBJECT_STORE_ID], 'readwrite').objectStore(OBJECT_STORE_ID)[\"delete\"](id);\n  return new Promise(function (res) {\n    request.onsuccess = function () {\n      return res();\n    };\n  });\n}\nexport function getOldMessages(db, ttl) {\n  var olderThen = new Date().getTime() - ttl;\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        var msgObk = cursor.value;\n\n        if (msgObk.time < olderThen) {\n          ret.push(msgObk); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n          cursor[\"continue\"]();\n        } else {\n          // no more old messages,\n          res(ret);\n          return;\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function cleanOldMessages(db, ttl) {\n  return getOldMessages(db, ttl).then(function (tooOld) {\n    return Promise.all(tooOld.map(function (msgObj) {\n      return removeMessageById(db, msgObj.id);\n    }));\n  });\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  return createDatabase(channelName).then(function (db) {\n    var state = {\n      closed: false,\n      lastCursorId: 0,\n      channelName: channelName,\n      options: options,\n      uuid: randomToken(),\n\n      /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */\n      eMIs: new ObliviousSet(options.idb.ttl * 2),\n      // ensures we do not read messages in parrallel\n      writeBlockPromise: Promise.resolve(),\n      messagesCallback: null,\n      readQueuePromises: [],\n      db: db\n    };\n    /**\n     * Handle abrupt closes that do not originate from db.close().\n     * This could happen, for example, if the underlying storage is\n     * removed or if the user clears the database in the browser's\n     * history preferences.\n     */\n\n    db.onclose = function () {\n      state.closed = true;\n      if (options.idb.onclose) options.idb.onclose();\n    };\n    /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */\n\n\n    _readLoop(state);\n\n    return state;\n  });\n}\n\nfunction _readLoop(state) {\n  if (state.closed) return;\n  readNewMessages(state).then(function () {\n    return sleep(state.options.idb.fallbackInterval);\n  }).then(function () {\n    return _readLoop(state);\n  });\n}\n\nfunction _filterMessage(msgObj, state) {\n  if (msgObj.uuid === state.uuid) return false; // send by own\n\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\n\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n\n  return true;\n}\n/**\n * reads all new messages from the database and emits them\n */\n\n\nfunction readNewMessages(state) {\n  // channel already closed\n  if (state.closed) return Promise.resolve(); // if no one is listening, we do not need to scan for new messages\n\n  if (!state.messagesCallback) return Promise.resolve();\n  return getMessagesHigherThan(state.db, state.lastCursorId).then(function (newerMessages) {\n    var useMessages = newerMessages\n    /**\n     * there is a bug in iOS where the msgObj can be undefined some times\n     * so we filter them out\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\n     */\n    .filter(function (msgObj) {\n      return !!msgObj;\n    }).map(function (msgObj) {\n      if (msgObj.id > state.lastCursorId) {\n        state.lastCursorId = msgObj.id;\n      }\n\n      return msgObj;\n    }).filter(function (msgObj) {\n      return _filterMessage(msgObj, state);\n    }).sort(function (msgObjA, msgObjB) {\n      return msgObjA.time - msgObjB.time;\n    }); // sort by time\n\n    useMessages.forEach(function (msgObj) {\n      if (state.messagesCallback) {\n        state.eMIs.add(msgObj.id);\n        state.messagesCallback(msgObj.data);\n      }\n    });\n    return Promise.resolve();\n  });\n}\n\nexport function close(channelState) {\n  channelState.closed = true;\n  channelState.db.close();\n}\nexport function postMessage(channelState, messageJson) {\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {\n    return writeMessage(channelState.db, channelState.uuid, messageJson);\n  }).then(function () {\n    if (randomInt(0, 10) === 0) {\n      /* await (do not await) */\n      cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n    }\n  });\n  return channelState.writeBlockPromise;\n}\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n  readNewMessages(channelState);\n}\nexport function canBeUsed() {\n  if (isNode) return false;\n  var idb = getIdb();\n  if (!idb) return false;\n  return true;\n}\nexport function averageResponseTime(options) {\n  return options.idb.fallbackInterval * 2;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}